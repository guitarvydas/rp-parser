(in-package :rp-parser)

(defmethod <rp> ((p parser))
  (let ((tlist (token-stream p))
	(new-list nil))
    ;; preprocess - filter out all ws and comments
    (push (next-token p) tlist)    
    (@:loop
      (@:exit-when (null tlist))
      (let ((tok (pop tlist)))
	(cond ((eq :space (token-kind tok)))
	      ((eq :comment (token-kind tok)))
	      (t (push tok new-list)))))
    (initially p (reverse new-list)))
  (@:loop
    (if (parser-success? (lookahead-char? p #\~))
	(<filter-stream> p)
	(if (parser-success? (lookahead-char? p #\=))
	    (<parse-rule> p)
	    (if (parser-success? (lookahead-char? p #\-))
		(<parse-predicate> p)
		(@:exit-when t))))) ;; else exit
  (input p :EOF)
  )

(defmethod <filter-stream> ((p parser))
  (input p :symbol)
  (let ((func (token-text (accepted-token p))))
    (emit-string p "(let ((%tokens (cons (next-token p) (token-stream p)))~%")
    (emit-string p "  (cl:loop (cl:when (null %tokens) (return)) (setf %tokens (~a p %tokens)))~%" func)
    (emit-string p " (initially self %tokens))")))

(defmethod <parse-token-expr> ((p parser))
  (cond ((parser-success? (lookahead-char? p #\'))
	 (input-char p #\')
	 (input-any-character p)
             (emit-string p "(input-char p #\\~a)" (token-text (accepted-token p)))
         (input-char p #\')
	 +succeed+)
	((parser-success? (look-upcase-symbol? p))
	 (input-upcase-symbol p)
	 (if (parser-success? (lookahead-char? p #\/))
	     ;; qualified token NAME/qual
             (progn
               (input-char p #\/)
	       ;; qual can be a SYMBOl or a single char
	       (if (parser-success? (lookahead? p :character))
		   (progn
		     (input-any-character p)
		     (emit-string p "(input-char p #\\~a)" (token-text (accepted-token p))))
		  (progn
		    (input p :symbol)
		    (emit-string p "(input-symbol p ~s)" (token-text (accepted-token p)))))
	       )
	   ;; unqualified token NAME
           (emit-string p "(input p :~a)" (token-text (accepted-token p))))
	 +succeed+)
	(t +fail+)))

(defmethod <parse-noop> ((p parser))
  (cond ((parser-success? (lookahead-char? p #\*))
	 (input-char p #\*)
             (emit-string p " t ")
	 +succeed+)
	(t +fail+)))

(defmethod <parse-expr> ((p parser))
  (cond ((parser-success? (<parse-token-expr> p)) +succeed+)
	((parser-success? (<parse-noop> p))       +succeed+)
	(t +fail+)))

(defmethod <parse-lookahead-token-expr> ((p parser))
  (cond ((parser-success? (lookahead-char? p #\'))
	 (input-char p #\')
	 (input-any-character p)
             (emit-string p "(parser-success? (lookahead-char? p #\\~a))" (token-text (accepted-token p)))
         (input-char p #\')
	 +succeed+)
	((parser-success? (look-upcase-symbol? p))
	 (input-upcase-symbol p)
	 (cond ((parser-success? (lookahead-char? p #\/))
                 ;; same as above (<parse-token-expr>) TOKEN/qual where qual can be a symbol or a character
                 ;; TOKEN/q where q is a :symbol or :character
                 (input-char p #\/)
                 (cond ((parser-success? (lookahead? p :character))
                        ;; q is :character
                        (input-any-character p)
                        (emit-string p "(parser-success? (lookahead-char? p #\\~a))" (token-text (accepted-token p))))
                       ;; else q is :symbol
                       (t
                        (input p :symbol)
                        (emit-string p "(parser-success? (look-symbol? p ~s))" (token-text (accepted-token p))))))
               (t (emit-string p "(parser-success? (lookahead? p :~a))" (token-text (accepted-token p)))))
         +succeed+)
        (t +fail+)))

(defmethod <parse-lookahead-noop> ((p parser))
  (cond ((parser-success? (lookahead-char? p #\*))
	 (input-char p #\*)
             (emit-string p " t ")
	 +succeed+)
	(t +fail+)))

(defmethod <parse-lookahead-expr> ((p parser))
  (cond ((parser-success? (<parse-lookahead-token-expr> p)) +succeed+)
	((parser-success? (<parse-lookahead-noop> p))       +succeed+)
	(t +fail+)))

(defmethod <parse-statement> ((p parser))
  (cond ((parser-success? (<parse-cycle> p)) +succeed+)
	((parser-success? (<parse-choice> p)) +succeed+)
	((parser-success? (<parse-return> p)) +succeed+)
	((parser-success? (<parse-cycle-exit> p)) +succeed+)
	((parser-success? (<parse-input-token> p)) +succeed+)
	((parser-success? (<parse-lookahead> p)) +succeed+)
	((parser-success? (<parse-noop> p)) +succeed+)
	((parser-success? (<parse-rule-call> p)) +succeed+)
	((parser-success? (<parse-predicate-call> p)) +succeed+)
	((parser-success? (<parse-external-call> p)) +succeed+)
	(t +fail+)))

(defmethod <parse-statements> ((p parser))
  (let ((result +fail+))
  (@:loop
   (@:exit-when (not (parser-success? (<parse-statement> p))))
   (emit-string p "~%")
   (setf result +succeed+))
  result))

(defmethod <parse-choice-statements> ((p parser))
  (let ((result +fail+))
  (@:loop
   (@:exit-when (not (parser-success? (<parse-statement> p))))
   (setf result +succeed+))
  result))

(defmethod <parse-cycle> ((p parser))
  (cond ((parser-success? (lookahead-char? p #\{))
	 (input-char p #\{)
                 (emit-string p "~&(loop~%")
	 (<parse-statements> p)
	 (input-char p #\})
                 (emit-string p ") ;;loop~%")
	 +succeed+)
	(t +fail+)))

(defmethod <parse-choice> ((p parser))
  (cond ((parser-success? (lookahead-char? p #\[))
	 (input-char p #\[)
             (emit-string p "~&(cond~%")
             (emit-string p "(")
	 (<parse-choice-statements> p)
             (emit-string p ");choice clause~%")
         (@:loop
           (@:exit-when (not (parser-success? (lookahead-char? p #\|))))
           (input-char p #\|)
               (emit-string p "(")
           (<parse-statements> p)
               (emit-string p ");choice alt~%"))
	 (input-char p #\])
            (emit-string p ");choice~%")
	 +succeed+)
	(t +fail+)))

(defmethod <parse-choice-alternate> ((p parser))
  (cond ((parser-success? (lookahead-char? p #\|))
	 (input-char p #\|)
             (emit-string p "(")
	 (<parse-statements> p)
             (emit-string p ") ;; alternate~%")
	 +succeed+)
	(t +fail+)))

(defmethod <parse-input-token> ((p parser))
  (<parse-expr> p))

(defmethod error-if-not-success ((p parser) value)
  (if (eq +succeed+ value)
      +succeed+
      (rp-parse-error p "")))

(defmethod <parse-lookahead> ((p parser))
  (cond ((parser-success? (lookahead-char? p #\?))
	 (input-char p #\?)
	 (error-if-not-success p (<parse-lookahead-expr> p))
	 +succeed+)
	(t +fail+)))
  
(defmethod <parse-rule-call> ((p parser))
  (cond ((parser-success? (lookahead-char? p #\@))
	 (input-char p #\@)
	 (input p :symbol)
            (emit-string p "(call-rule p #'~a)" (token-text (accepted-token p)))
	 +succeed+)
	(t +fail+)))

(defmethod <parse-predicate-call> ((p parser))
  (cond ((parser-success? (lookahead-char? p #\&))
	 (input-char p #\&)
	 (input p :symbol)
            (emit-string p "(parser-success? (call-predicate p #'~a))" (token-text (accepted-token p)))
	 +succeed+)
	(t +fail+)))

(defmethod <parse-external-call> ((p parser))
  (cond ((parser-success? (lookahead? p :symbol))
	 (input p :symbol)
               (emit-string p "(call-external p #'~a)" (token-text (accepted-token p)))
	 +succeed+)
	(t +fail+)))

(defmethod <parse-cycle-exit> ((p parser))
  (cond ((parser-success? (lookahead-char? p #\>))
	 (input-char p #\>)
           (emit-string p "(return)")
	 +succeed+)
	(t +fail+)))

(defmethod <parse-return> ((p parser))
  (cond ((parser-success? (lookahead-char? p #\^))
	 (input-char p #\^)
	 (input p :symbol)
	 (error-if-not-success p
	  (if (string= "fail" (token-text (accepted-token p)))
	      (progn
                      (emit-string p "(return-from ~a +fail+)" (current-rule p))
                +succeed+)
	      (if (string= "ok" (token-text (accepted-token p)))
		  (progn
                      (emit-string p "(return-from ~a +succeed+)" (current-rule p))
                    +succeed+)
		  +fail+)))
	 +succeed+)
	(t +fail+)))
  
(defmethod <parse-rule> ((p parser))
  (input-char p #\=)
  (input p :symbol)
  (setf (current-rule p) (token-text (accepted-token p)))
             (emit-string p "(defmethod ~a ((p parser))~%" (current-rule p))
  (<parse-statements> p)
             (emit-string p ") ; rule~%~%")
  +succeed+
  )

(defmethod <parse-predicate> ((p parser))
  (input-char p #\-)
  (input p :symbol)
  (setf (current-rule p) (token-text (accepted-token p)))
             (emit-string p "(defmethod ~a ((p parser)) ;; predicate~%" (current-rule p))
  (<parse-statements> p)
             (emit-string p ") ; pred~%~%")
  +succeed+
  )

