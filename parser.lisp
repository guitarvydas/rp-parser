(in-package :rp-parser)

(defmethod <rp> ((p parser))
  (let ((tlist (rpa:token-stream p))
	(new-list nil))
    ;; preprocess - filter out all ws and comments
    (push (rpa:next-token p) tlist)    
    (@:loop
      (@:exit-when (null tlist))
      (let ((tok (pop tlist)))
	(cond ((eq :space (rephrase:token-kind tok)))
	      ((eq :comment (rephrase:token-kind tok)))
	      (t (push tok new-list)))))
    (rpa:initially p (reverse new-list)))
  (@:loop
    (if (rpa:parser-success? (rpa:lookahead-char? p #\~))
	(<filter-stream> p)
	(if (rpa:parser-success? (rpa:lookahead-char? p #\=))
	    (<parse-rule> p)
	    (if (rpa:parser-success? (rpa:lookahead-char? p #\-))
		(<parse-predicate> p)
		(@:exit-when t))))) ;; else exit
  (rpa:input p :EOF)
  )

(defmethod <filter-stream> ((p parser))
  (rpa:input p :symbol)
  (let ((func (rephrase:token-text (rpa:accepted-token p))))
    (rpa:emit-string p "(:let ((%tokens (cons (rpa:next-token p) (rpa:token-stream p)))~%")
    (rpa:emit-string p "  (loop (when (null %tokens) (return)) (setf %tokens (~a p %tokens)))~%" func)
    (rpa:emit-string p " (initially self %tokens))")))

(defmethod <parse-token-expr> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\'))
	 (rpa:input-char p #\')
	 (input-any-character p)
             (rpa:emit-string p "(rpa:input-char p #\\~a)" (rephrase:token-text (rpa:accepted-token p)))
         (rpa:input-char p #\')
	 rpa:+succeed+)
	((rpa:parser-success? (rp-parser::look-upcase-symbol? p))
	 (input-upcase-symbol p)
	 (if (rpa:parser-success? (rpa:lookahead-char? p #\/))
	     ;; qualified token NAME/qual
             (progn
               (rpa:input-char p #\/)
	       ;; qual can be a SYMBOl or a single char
	       (if (rpa:parser-success? (lookahead? p :character))
		   (progn
		     (input-any-character p)
		     (rpa:emit-string p "(rpa:input-char p #\\~a)" (rephrase:token-text (rpa:accepted-token p))))
		  (progn
		    (rpa:input p :symbol)
		    (rpa:emit-string p "(rpa:input-symbol p ~s)" (rephrase:token-text (rpa:accepted-token p)))))
	       )
	   ;; unqualified token NAME
           (rpa:emit-string p "(rpa:input p :~a)" (rephrase:token-text (rpa:accepted-token p))))
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-noop> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\*))
	 (rpa:input-char p #\*)
             (rpa:emit-string p " t ")
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-dot> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\.))
	 (rpa:input-char p #\.)
             (rpa:emit-string p " (rpa:accept p) ")
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-expr> ((p parser))
  (cond ((rpa:parser-success? (<parse-token-expr> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-noop> p))       rpa:+succeed+)
	((rpa:parser-success? (<parse-dot> p))        rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-lookahead-token-expr> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\'))
	 (rpa:input-char p #\')
	 (input-any-character p)
             (rpa:emit-string p "(rpa:parser-success? (rpa:lookahead-char? p #\\~a))" (rephrase:token-text (rpa:accepted-token p)))
         (rpa:input-char p #\')
	 rpa:+succeed+)
	((rpa:parser-success? (rp-parser::look-upcase-symbol? p))
	 (rp-parser::input-upcase-symbol p)
	 (cond ((rpa:parser-success? (rpa:lookahead-char? p #\/))
                 ;; same as above (<parse-token-expr>) TOKEN/qual where qual can be a symbol or a character
                 ;; TOKEN/q where q is a :symbol or :character
                 (rpa:input-char p #\/)
                 (cond ((rpa:parser-success? (rpa:lookahead? p :character))
                        ;; q is :character
                        (input-any-character p)
			(rpa:emit-string p "(rpa:parser-success? (rpa:lookahead-char? p #\\~a))" (rephrase:token-text (rpa:accepted-token p))))
                       ;; else q is :symbol
                       (t
                        (rpa:input p :symbol)
                        (rpa:emit-string p "(rpa:parser-success? (rpa:lookahead-symbol? p ~s))" (rephrase:token-text (rpa:accepted-token p))))))
               (t (rpa:emit-string p "(rpa:parser-success? (rpa:lookahead? p :~a))" (rephrase:token-text (rpa:accepted-token p)))))
         rpa:+succeed+)
        (t rpa:+fail+)))

(defmethod <parse-lookahead-noop> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\*))
	 (rpa:input-char p #\*)
             (rpa:emit-string p " t ")
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-lookahead-expr> ((p parser))
  (cond ((rpa:parser-success? (<parse-lookahead-token-expr> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-lookahead-noop> p))       rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-statement> ((p parser))
  (cond ((rpa:parser-success? (<parse-cycle> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-choice> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-return> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-cycle-exit> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-input-token> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-lookahead> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-noop> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-dot> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-rule-call> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-predicate-call> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-external-call> p)) rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-statements> ((p parser))
  (let ((result rpa:+fail+))
  (@:loop
   (@:exit-when (not (rpa:parser-success? (<parse-statement> p))))
   (rpa:emit-string p "~%")
   (setf result rpa:+succeed+))
  result))

(defmethod <parse-choice-statements> ((p parser))
  (let ((result rpa:+fail+))
  (@:loop
   (@:exit-when (not (rpa:parser-success? (<parse-statement> p))))
   (setf result rpa:+succeed+))
  result))

(defmethod <parse-cycle> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\{))
	 (rpa:input-char p #\{)
                 (rpa:emit-string p "~&(loop~%")
	 (<parse-statements> p)
	 (rpa:input-char p #\})
                 (rpa:emit-string p ") ;;loop~%")
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-choice> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\[))
	 (rpa:input-char p #\[)
             (rpa:emit-string p "~&(cond~%")
             (rpa:emit-string p "(")
	 (<parse-choice-statements> p)
             (rpa:emit-string p ");choice clause~%")
         (@:loop
           (@:exit-when (not (rpa:parser-success? (rpa:lookahead-char? p #\|))))
           (rpa:input-char p #\|)
               (rpa:emit-string p "(")
           (<parse-statements> p)
               (rpa:emit-string p ");choice alt~%"))
	 (rpa:input-char p #\])
            (rpa:emit-string p ");choice~%")
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-choice-alternate> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\|))
	 (rpa:input-char p #\|)
             (rpa:emit-string p "(")
	 (<parse-statements> p)
             (rpa:emit-string p ") ;; alternate~%")
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-input-token> ((p parser))
  (<parse-expr> p))

(defmethod error-if-not-success ((p parser) value)
  (if (eq rpa:+succeed+ value)
      rpa:+succeed+
      (rp-parse-error p "")))

(defmethod <parse-lookahead> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\?))
	 (rpa:input-char p #\?)
	 (error-if-not-success p (<parse-lookahead-expr> p))
	 rpa:+succeed+)
	(t rpa:+fail+)))
  
(defmethod <parse-rule-call> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\@))
	 (rpa:input-char p #\@)
	 (rpa:input p :symbol)
            (rpa:emit-string p "(rpa:call-rule p #'~a)" (rephrase:token-text (rpa:accepted-token p)))
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-predicate-call> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\&))
	 (rpa:input-char p #\&)
	 (rpa:input p :symbol)
            (rpa:emit-string p "(rpa:parser-success? (rpa:call-predicate p #'~a))" (rephrase:token-text (rpa:accepted-token p)))
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-external-call> ((p parser))
  (cond ((rpa:parser-success? (lookahead? p :symbol))
	 (rpa:input p :symbol)
               (rpa:emit-string p "(rpa:call-external p #'~a)" (rephrase:token-text (rpa:accepted-token p)))
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-cycle-exit> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\>))
	 (rpa:input-char p #\>)
           (rpa:emit-string p "(return)")
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-return> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\^))
	 (rpa:input-char p #\^)
	 (rpa:input p :symbol)
	 (error-if-not-success p
	  (if (string= "fail" (rephrase:token-text (rpa:accepted-token p)))
	      (progn
                      (rpa:emit-string p "(return-from ~a rpa:+fail+)" (rpa::current-rule p))
                rpa:+succeed+)
	      (if (string= "ok" (rephrase:token-text (rpa:accepted-token p)))
		  (progn
                      (rpa:emit-string p "(return-from ~a rpa:+succeed+)" (rpa::current-rule p))
                    rpa:+succeed+)
		  rpa:+fail+)))
	 rpa:+succeed+)
	(t rpa:+fail+)))
  
(defmethod <parse-rule> ((p parser))
  (rpa:input-char p #\=)
  (rpa:input p :symbol)
  (setf (rpa::current-rule p) (rephrase:token-text (rpa:accepted-token p)))
             (rpa:emit-string p "(defmethod ~a ((p rpa:parser))~%" (rpa::current-rule p))
  (<parse-statements> p)
             (rpa:emit-string p ") ; rule~%~%")
  rpa:+succeed+
  )

(defmethod <parse-predicate> ((p parser))
  (rpa:input-char p #\-)
  (rpa:input p :symbol)
  (setf (rpa::current-rule p) (rephrase:token-text (rpa:accepted-token p)))
             (rpa:emit-string p "(defmethod ~a ((p rpa:parser)) ;; predicate~%" (rpa::current-rule p))
  (<parse-statements> p)
             (rpa:emit-string p ") ; pred~%~%")
  rpa:+succeed+
  )

